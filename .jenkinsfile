
// ============================================================================
// Global properties
// ============================================================================

// Start build every night between 1:00-4:59
// Keep only last 10 builds
properties([
    pipelineTriggers(
        [cron(env.BRANCH_NAME == 'master' ? 'H H(1-4) * * *' : '')]
    ),
    buildDiscarder(
        logRotator(artifactDaysToKeepStr: '', artifactNumToKeepStr: '', daysToKeepStr: '', numToKeepStr: '10')
    )
])

// Checks whether the current build was triggered by cron job.
// We need this to check, whether we want to trigger a deployment
// step for a stable nightly build.
def is_triggered_by_cron()
{
    for (cause in currentBuild.rawBuild.getCauses())
    {
        if (cause instanceof TimerTrigger.TimerTriggerCause)
            return true
        return false
    }
}

// Check if this build is a nightly build (only master supports building periodically)
Boolean is_nightly = is_triggered_by_cron()

// ============================================================================
// Define test functions
// ============================================================================

/* Executes unit tests
 * \param slave_name   The name of the slave this test is executed on; String
 * \param compiler     The name of the compiler to use; String
 * \param build_type   The build type to use [Debug, Release]; String
 * \param model        The model [Nightly, Continuous]; String
 */
def run_unit_tests(slave_name, compiler, build_type, model)
{
    def build_name
    def cxx
    def workspace
    def platform
    def checkout_dir

    stage ('initialise')
    {
        workspace = pwd()
        echo workspace
        // Clean the workspace before building.
        deleteDir()

        build_name = "$slave_name $compiler $build_type $env.BRANCH_NAME Build-$env.BUILD_NUMBER"
        platform = sh(script: 'uname -s', returnStdout: true).trim()

        // sh 'git clone https://github.com/seqan/seqan3-infrastructure.git seqan3-infra'
        cxx = sh(script: "which $compiler", returnStdout: true).trim()

        // Perform checkout in specific location.
        // The relative folder structure is important for the ctest script.
        dir('checkout')
        {
            checkout scm
            checkout_dir = pwd()
        }
    }

    stage('configure')
    {
        dir("$workspace/build")
        {
            sh "cmake $checkout_dir/sdsl-lite -DCMAKE_BUILD_TYPE=$build_type -DCMAKE_CXX_COMPILER=$compiler"
        }
    }

    stage('build')
    {
        dir("$workspace/build")
        {
            sh "make -j 4"
        }
    }

    stage('run')
    {
        dir("$workspace/build")
        {
            sh "ctest -j 4 --no-compress-output -VV --output-on-failure"
        }
    }

    // try
    // {
    //     // Prepare environment and run ctest step.
    //     withEnv(["BUILDNAME=$build_name",
    //              "PLATFORM=$platform",
    //              "MODEL=$model",
    //              "TEST_MODEL=unit",
    //              "WORKSPACE=$workspace",
    //              "SITE_NAME=jenkins",
    //              "DISABLE_CEREAL=$disable_cereal",
    //              "CTEST_BUILD_TYPE=$build_type",
    //              "CXX=$cxx"])
    //     {
    //         stage('run')
    //         {
    //             dir(workspace)
    //             {
    //                 sh "ctest --no-compress-output -VV -S $workspace/seqan3-infra/ctest/seqan3_jenkins.cmake"
    //             }
    //         }
    //     }
    // }
    // catch (Exception ex)
    // {
    //     currentBuild.result = 'failure'
    //     if (env.CHANGE_ID)
    //         pullRequest.createStatus(status: 'failure',
    //                                  context: 'continuous-integration/jenkins/pr-merge',
    //                                  description: 'Running ctest failed.')
    //     throw ex
    // }
}

// ============================================================================
// Define unit test matrix
// ============================================================================

// Configure unit tests. Add platforms here but adapt the inner loop of the matrix setup to call instantiate and
// setup the right agent.
def axis_agent = ["ubuntu"]
def axis_compiler = ["g++-4.9", "g++-5"] // g++-6, g++-7, g++-8, clang++
def axis_build_type =["Release", "Debug"]
def tasks = [:]

// The following nested for loops define the compiler matrix for the unit tests.
// First iterate over all supported compiler versions
// If the compilers do not match on the respective platform either use a different scope to
// iterate over them or define some kind of map to point to the right compiler name per platform.
for(int i = 0; i < axis_compiler.size(); ++i)
{
    def axis_compiler_value = axis_compiler[i]
    def subTasks = [:] // defines subtask per compiler; later we can make it per platform.
    for (int k = 0; k < axis_build_type.size(); ++k) // Whether to build in release or debug mode
    {
        def axis_build_type_value = axis_build_type[k]
        // Only build nightlies in debug and release mode
        if (!is_nightly && (axis_build_type_value == "Release"))
            continue

        def test_model = is_nightly ? 'Nightly' : 'Continuous'
        def label = "ubuntu_${axis_compiler_value}_$axis_build_type_value"
        subTasks[label] =
        {
            node("ubuntu && $axis_compiler_value")
            {
                // For docker nodes we need to define the workspace explicitly, as they use a mounted
                // volume on the filesystem which is shared by all docker instances. Since the docker executor
                // doesn't know the other running instances it cannot locking the workspace.
                ws("$env.WORKSPACE")
                {
                    stage('install')
                    {
                        sh """
                            sudo apt-get update
                            sudo apt-get install -y $axis_compiler_value cmake git
                        """

                    }
                    run_unit_tests(env.DOCKER_SLAVE_NAME,
                                   axis_compiler_value,
                                   axis_build_type_value,
                                   test_model)
                }
            }
        }
    }
    tasks["ubuntu-${axis_compiler_value}"] =
    {
        parallel subTasks
    }
}

/* TODO sanitizer builds
 * g++-7 sanitizer options
 */

/* TODO doc builds
 * user develop
 */

/* TODO coverage build
 * g++-8 debug mode
 */

/* TODO valgrind build
 *
 */

/* TODO performance build
 * g++-7, g++-8 [, g++-9] [, clang-concpets]
 */

// ============================================================================
// Execute build matrix
// ============================================================================

// This is the main stage that executes all jobs registered in the tasks map
// All steps are executed in parallel. If the contention on the agents are to high
// consider moving some tasks out into another stage that runs after this one.
stage ("matrix")
{
    parallel tasks
}
